//
//  ProjectGenerator.swift
//  BRT Studio - Project Scaffold Generator
//
//  Copyright © 2025 Black Room Technologies. All rights reserved.
//

import Foundation

/// Generates complete project scaffolds from specifications
actor ProjectGenerator {
    private let fileManager = FileManager.default
    private let logger = AppLogger.shared

    /// Generate a complete project
    func generateProject(
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws -> GeneratedProject {

        await logger.log(.info, "Generating project", metadata: ["stack": stack.type.rawValue])

        // Create output directory
        let outputPath = try createOutputDirectory(projectName: sanitizeProjectName(spec.purpose))

        // Initialize Git repository
        try await initializeGitRepository(at: outputPath)

        // Generate project files based on stack type
        switch stack.type {
        case .macOSNative:
            try await generateSwiftUIProject(
                at: outputPath,
                spec: spec,
                stack: stack,
                architecture: architecture
            )

        case .crossPlatformGUI:
            try await generateTauriProject(
                at: outputPath,
                spec: spec,
                stack: stack,
                architecture: architecture
            )

        case .cli:
            try await generateCLIProject(
                at: outputPath,
                spec: spec,
                stack: stack,
                architecture: architecture
            )

        case .pythonScript:
            try await generatePythonProject(
                at: outputPath,
                spec: spec,
                stack: stack,
                architecture: architecture
            )

        default:
            try await generateGenericProject(
                at: outputPath,
                spec: spec,
                stack: stack,
                architecture: architecture
            )
        }

        // Generate common files
        try await generateREADME(at: outputPath, spec: spec, stack: stack)
        try await generateLicense(at: outputPath, license: spec.license)
        try await generateGitignore(at: outputPath, stack: stack)
        try await generateCHANGELOG(at: outputPath)

        // Generate build scripts
        if stack.platform == .macOS {
            try await generateBuildScripts(at: outputPath, stack: stack)
        }

        await logger.log(.info, "Project generation complete", metadata: ["path": outputPath.path])

        // Create project metadata
        let metadata = ProjectMetadata(
            license: spec.license,
            author: "Generated by BRT Studio",
            version: "0.1.0",
            tags: [stack.type.rawValue, stack.language.rawValue]
        )

        return GeneratedProject(
            name: sanitizeProjectName(spec.purpose),
            description: spec.purpose,
            stack: stack,
            architecture: architecture,
            outputPath: outputPath,
            metadata: metadata
        )
    }

    // MARK: - Stack-Specific Generators

    private func generateSwiftUIProject(
        at path: URL,
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws {
        let projectName = sanitizeProjectName(spec.purpose)

        // Create directory structure
        let sources = path.appendingPathComponent("Sources/\(projectName)")
        try fileManager.createDirectory(at: sources, withIntermediateDirectories: true)

        // Generate Package.swift
        let packageSwift = SwiftUITemplate.generatePackageSwift(projectName: projectName, spec: spec)
        try packageSwift.write(to: path.appendingPathComponent("Package.swift"), atomically: true, encoding: .utf8)

        // Generate App files
        let appDir = sources.appendingPathComponent("App")
        try fileManager.createDirectory(at: appDir, withIntermediateDirectories: true)

        let appFile = SwiftUITemplate.generateApp(projectName: projectName)
        try appFile.write(to: appDir.appendingPathComponent("\(projectName)App.swift"), atomically: true, encoding: .utf8)

        // Generate ContentView
        let viewsDir = sources.appendingPathComponent("Views")
        try fileManager.createDirectory(at: viewsDir, withIntermediateDirectories: true)

        let contentView = SwiftUITemplate.generateContentView()
        try contentView.write(to: viewsDir.appendingPathComponent("ContentView.swift"), atomically: true, encoding: .utf8)

        // Generate Settings
        let settingsView = SwiftUITemplate.generateSettingsView()
        try settingsView.write(to: viewsDir.appendingPathComponent("SettingsView.swift"), atomically: true, encoding: .utf8)

        // Generate Models
        if spec.needsDatabase {
            let modelsDir = sources.appendingPathComponent("Models")
            try fileManager.createDirectory(at: modelsDir, withIntermediateDirectories: true)

            let exampleModel = SwiftUITemplate.generateExampleModel()
            try exampleModel.write(to: modelsDir.appendingPathComponent("ExampleModel.swift"), atomically: true, encoding: .utf8)
        }

        // Generate Tests
        if spec.needsTesting {
            let testsDir = path.appendingPathComponent("Tests/\(projectName)Tests")
            try fileManager.createDirectory(at: testsDir, withIntermediateDirectories: true)

            let testFile = SwiftUITemplate.generateTests(projectName: projectName)
            try testFile.write(to: testsDir.appendingPathComponent("\(projectName)Tests.swift"), atomically: true, encoding: .utf8)
        }

        await logger.log(.info, "SwiftUI project structure generated")
    }

    private func generateTauriProject(
        at path: URL,
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws {
        // Create Tauri project structure
        let srcDir = path.appendingPathComponent("src")
        let srcTauriDir = path.appendingPathComponent("src-tauri")

        try fileManager.createDirectory(at: srcDir, withIntermediateDirectories: true)
        try fileManager.createDirectory(at: srcTauriDir, withIntermediateDirectories: true)

        // Generate tauri.conf.json
        let tauriConfig = TauriTemplate.generateConfig(projectName: sanitizeProjectName(spec.purpose))
        try tauriConfig.write(to: srcTauriDir.appendingPathComponent("tauri.conf.json"), atomically: true, encoding: .utf8)

        // Generate Cargo.toml
        let cargoToml = TauriTemplate.generateCargoToml(projectName: sanitizeProjectName(spec.purpose))
        try cargoToml.write(to: srcTauriDir.appendingPathComponent("Cargo.toml"), atomically: true, encoding: .utf8)

        // Generate main.rs
        let mainRs = TauriTemplate.generateMainRs()
        try mainRs.write(to: srcTauriDir.appendingPathComponent("src/main.rs"), atomically: true, encoding: .utf8)

        // Generate index.html
        let indexHtml = TauriTemplate.generateIndexHtml(projectName: sanitizeProjectName(spec.purpose))
        try indexHtml.write(to: srcDir.appendingPathComponent("index.html"), atomically: true, encoding: .utf8)

        await logger.log(.info, "Tauri project structure generated")
    }

    private func generateCLIProject(
        at path: URL,
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws {
        if stack.language == .rust {
            // Generate Rust CLI
            let cargoToml = RustTemplate.generateCargoToml(projectName: sanitizeProjectName(spec.purpose), isCLI: true)
            try cargoToml.write(to: path.appendingPathComponent("Cargo.toml"), atomically: true, encoding: .utf8)

            let srcDir = path.appendingPathComponent("src")
            try fileManager.createDirectory(at: srcDir, withIntermediateDirectories: true)

            let mainRs = RustTemplate.generateCLIMain(projectName: sanitizeProjectName(spec.purpose))
            try mainRs.write(to: srcDir.appendingPathComponent("main.rs"), atomically: true, encoding: .utf8)
        }

        await logger.log(.info, "CLI project structure generated")
    }

    private func generatePythonProject(
        at path: URL,
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws {
        // Generate pyproject.toml
        let pyprojectToml = PythonTemplate.generatePyprojectToml(projectName: sanitizeProjectName(spec.purpose), spec: spec)
        try pyprojectToml.write(to: path.appendingPathComponent("pyproject.toml"), atomically: true, encoding: .utf8)

        // Generate package structure
        let packageName = sanitizeProjectName(spec.purpose).lowercased().replacingOccurrences(of: "-", with: "_")
        let packageDir = path.appendingPathComponent(packageName)
        try fileManager.createDirectory(at: packageDir, withIntermediateDirectories: true)

        let initPy = PythonTemplate.generateInit()
        try initPy.write(to: packageDir.appendingPathComponent("__init__.py"), atomically: true, encoding: .utf8)

        let mainPy = PythonTemplate.generateMain(spec: spec)
        try mainPy.write(to: packageDir.appendingPathComponent("main.py"), atomically: true, encoding: .utf8)

        // Generate tests
        if spec.needsTesting {
            let testsDir = path.appendingPathComponent("tests")
            try fileManager.createDirectory(at: testsDir, withIntermediateDirectories: true)

            let testInit = ""
            try testInit.write(to: testsDir.appendingPathComponent("__init__.py"), atomically: true, encoding: .utf8)

            let testMain = PythonTemplate.generateTests()
            try testMain.write(to: testsDir.appendingPathComponent("test_main.py"), atomically: true, encoding: .utf8)
        }

        await logger.log(.info, "Python project structure generated")
    }

    private func generateGenericProject(
        at path: URL,
        spec: ProjectSpecification,
        stack: TechStack,
        architecture: ProjectArchitecture
    ) async throws {
        // Generic fallback structure
        let srcDir = path.appendingPathComponent("src")
        try fileManager.createDirectory(at: srcDir, withIntermediateDirectories: true)

        let readme = "# \(sanitizeProjectName(spec.purpose))\n\nGenerated by BRT Studio"
        try readme.write(to: srcDir.appendingPathComponent("README.md"), atomically: true, encoding: .utf8)

        await logger.log(.info, "Generic project structure generated")
    }

    // MARK: - Common File Generators

    private func generateREADME(at path: URL, spec: ProjectSpecification, stack: TechStack) async throws {
        let readme = """
        # \(sanitizeProjectName(spec.purpose))

        \(spec.purpose)

        ## Stack

        - **Type:** \(stack.type.rawValue)
        - **Language:** \(stack.language.rawValue)
        - **Framework:** \(stack.framework)
        - **Build System:** \(stack.buildSystem.rawValue)

        ## Getting Started

        \(getStartedInstructions(for: stack))

        ## Project Structure

        ```
        \(generateProjectStructureTree(for: stack))
        ```

        ## Build

        \(getBuildInstructions(for: stack))

        ## Tests

        \(getTestInstructions(for: stack))

        ## License

        This project is licensed under the \(spec.license.rawValue) License.

        ---

        *Generated by BRT Studio - Black Room Technologies*
        """

        try readme.write(to: path.appendingPathComponent("README.md"), atomically: true, encoding: .utf8)
    }

    private func generateLicense(at path: URL, license: ProjectMetadata.License) async throws {
        let licenseText: String

        switch license {
        case .apache2:
            licenseText = LicenseTemplates.apache2
        case .mit:
            licenseText = LicenseTemplates.mit
        case .gpl3:
            licenseText = LicenseTemplates.gpl3
        case .bsd3:
            licenseText = LicenseTemplates.bsd3
        case .proprietary:
            licenseText = "Proprietary License\n\nAll rights reserved."
        }

        try licenseText.write(to: path.appendingPathComponent("LICENSE"), atomically: true, encoding: .utf8)
    }

    private func generateGitignore(at path: URL, stack: TechStack) async throws {
        var gitignore = "# BRT Studio Generated .gitignore\n\n"

        switch stack.language {
        case .swift:
            gitignore += GitignoreTemplates.swift
        case .rust:
            gitignore += GitignoreTemplates.rust
        case .python:
            gitignore += GitignoreTemplates.python
        case .typescript, .javascript:
            gitignore += GitignoreTemplates.node
        }

        gitignore += "\n# macOS\n.DS_Store\n"

        try gitignore.write(to: path.appendingPathComponent(".gitignore"), atomically: true, encoding: .utf8)
    }

    private func generateCHANGELOG(at path: URL) async throws {
        let changelog = """
        # Changelog

        All notable changes to this project will be documented in this file.

        ## [0.1.0] - \(ISO8601DateFormatter().string(from: Date()).prefix(10))

        ### Added
        - Initial project scaffold generated by BRT Studio
        """

        try changelog.write(to: path.appendingPathComponent("CHANGELOG.md"), atomically: true, encoding: .utf8)
    }

    private func generateBuildScripts(at path: URL, stack: TechStack) async throws {
        let scriptsDir = path.appendingPathComponent("scripts")
        try fileManager.createDirectory(at: scriptsDir, withIntermediateDirectories: true)

        // Build script
        let buildScript = """
        #!/bin/bash
        # Build script for \(sanitizeProjectName("project"))

        set -e

        echo "Building project..."

        \(getBuildCommand(for: stack))

        echo "Build complete!"
        """

        let buildPath = scriptsDir.appendingPathComponent("build.sh")
        try buildScript.write(to: buildPath, atomically: true, encoding: .utf8)

        // Make executable
        try fileManager.setAttributes([.posixPermissions: 0o755], ofItemAtPath: buildPath.path)
    }

    // MARK: - Helper Methods

    private func createOutputDirectory(projectName: String) throws -> URL {
        let projectsDir = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
            .appendingPathComponent("BRTStudio")
            .appendingPathComponent("Generated")

        try fileManager.createDirectory(at: projectsDir, withIntermediateDirectories: true)

        let projectPath = projectsDir.appendingPathComponent(projectName)

        // If exists, add timestamp suffix
        var finalPath = projectPath
        if fileManager.fileExists(atPath: projectPath.path) {
            let timestamp = Int(Date().timeIntervalSince1970)
            finalPath = projectsDir.appendingPathComponent("\(projectName)-\(timestamp)")
        }

        try fileManager.createDirectory(at: finalPath, withIntermediateDirectories: true)

        return finalPath
    }

    private func initializeGitRepository(at path: URL) async throws {
        let process = Process()
        process.currentDirectoryURL = path
        process.executableURL = URL(fileURLWithPath: "/usr/bin/git")
        process.arguments = ["init"]

        try process.run()
        process.waitUntilExit()

        await logger.log(.info, "Git repository initialized")
    }

    private func sanitizeProjectName(_ name: String) -> String {
        return name
            .components(separatedBy: .whitespacesAndNewlines)
            .joined(separator: "-")
            .components(separatedBy: .punctuationCharacters)
            .joined(separator: "-")
            .lowercased()
            .prefix(50)
            .description
    }

    private func getStartedInstructions(for stack: TechStack) -> String {
        switch stack.language {
        case .swift:
            return """
            ### Prerequisites
            - Xcode 15.0+ (for macOS development)
            - Swift 5.10+

            ### Installation
            ```bash
            git clone <repository>
            cd <project>
            swift build
            ```
            """
        case .rust:
            return """
            ### Prerequisites
            - Rust 1.70+
            - Cargo

            ### Installation
            ```bash
            git clone <repository>
            cd <project>
            cargo build
            ```
            """
        case .python:
            return """
            ### Prerequisites
            - Python 3.11+
            - Poetry

            ### Installation
            ```bash
            git clone <repository>
            cd <project>
            poetry install
            ```
            """
        default:
            return "See documentation for installation instructions."
        }
    }

    private func getBuildInstructions(for stack: TechStack) -> String {
        switch stack.buildSystem {
        case .swiftpm:
            return "```bash\nswift build\n```"
        case .cargo:
            return "```bash\ncargo build --release\n```"
        case .poetry:
            return "```bash\npoetry build\n```"
        case .npm:
            return "```bash\nnpm run build\n```"
        default:
            return "See build system documentation."
        }
    }

    private func getTestInstructions(for stack: TechStack) -> String {
        switch stack.buildSystem {
        case .swiftpm:
            return "```bash\nswift test\n```"
        case .cargo:
            return "```bash\ncargo test\n```"
        case .poetry:
            return "```bash\npoetry run pytest\n```"
        case .npm:
            return "```bash\nnpm test\n```"
        default:
            return "See testing documentation."
        }
    }

    private func getBuildCommand(for stack: TechStack) -> String {
        switch stack.buildSystem {
        case .swiftpm:
            return "swift build -c release"
        case .cargo:
            return "cargo build --release"
        case .poetry:
            return "poetry build"
        case .npm:
            return "npm run build"
        default:
            return "echo 'Build command not configured'"
        }
    }

    private func generateProjectStructureTree(for stack: TechStack) -> String {
        switch stack.language {
        case .swift:
            return """
            .
            ├── Package.swift
            ├── Sources/
            │   └── YourProject/
            │       ├── App/
            │       ├── Views/
            │       └── Models/
            ├── Tests/
            └── README.md
            """
        case .rust:
            return """
            .
            ├── Cargo.toml
            ├── src/
            │   └── main.rs
            ├── tests/
            └── README.md
            """
        case .python:
            return """
            .
            ├── pyproject.toml
            ├── your_project/
            │   ├── __init__.py
            │   └── main.py
            ├── tests/
            └── README.md
            """
        default:
            return "Project structure varies by stack."
        }
    }
}

// MARK: - Project Generation Error

enum ProjectGenerationError: LocalizedError {
    case invalidPath
    case fileCreationFailed(String)
    case unsupportedStack

    var errorDescription: String? {
        switch self {
        case .invalidPath:
            return "Invalid output path"
        case .fileCreationFailed(let file):
            return "Failed to create file: \(file)"
        case .unsupportedStack:
            return "Unsupported technology stack"
        }
    }
}
